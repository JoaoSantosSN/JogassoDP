<!DOCTYPE html>
<!-- Declara o tipo do documento como HTML5 -->
<html lang="pt-BR">
<!-- Abre o elemento root do HTML e define idioma como portugu√™s do Brasil -->
<head>
  <!-- In√≠cio do head (metadados) -->
  <meta charset="UTF-8">
  <!-- Define a codifica√ß√£o de caracteres para UTF-8 -->
  <title>Exerc√≠cio de Part√≠culas</title>
  <!-- T√≠tulo da p√°gina (aparece na aba do navegador) -->
  <style>
    /* Estilo interno: define apar√™ncia da p√°gina e do canvas */
    html, body { height: 100%; margin: 0; background: #111; overflow: hidden; }
    /* Faz o body ocupar toda a altura, remove margens, fundo escuro e evita scroll */
    canvas { display: block; margin: auto; background: #222; }
    /* Centraliza o canvas e define cor de fundo para ele */
    h2 { color: white; text-align: center; font-family: Arial; }
    /* Estiliza o t√≠tulo (cor, alinhamento e fonte) */
  </style>
  <!-- Fim do bloco de estilos -->
</head>
<body>
  <!-- Corpo da p√°gina (conte√∫do vis√≠vel) -->
  <h2>üí® Sistema de Part√≠culas ‚Äî Fuma√ßa no Deserto</h2>
  <!-- T√≠tulo explicativo para a atividade -->
  <canvas id="canvas"></canvas>
  <!-- Elemento canvas onde desenharemos as part√≠culas -->

  <script>
    // In√≠cio do script JavaScript

    const canvas = document.getElementById("canvas");
    // Pega a refer√™ncia do elemento <canvas> pelo id

    const ctx = canvas.getContext("2d");
    // Obt√©m o contexto 2D para desenhar (API do canvas)

    canvas.width = window.innerWidth;
    // Ajusta a largura do canvas para a largura da janela do navegador

    canvas.height = window.innerHeight;
    // Ajusta a altura do canvas para a altura da janela do navegador

    const smokeParticles = [];
    // Array que guarda todas as part√≠culas ativas (cada part√≠cula √© um objeto)

    // Cria novas part√≠culas a cada clique
    canvas.addEventListener("click", e => {
      // Ao clicar no canvas, executa esta fun√ß√£o passando o evento 'e'
      for (let i = 0; i < 20; i++) {
        // Cria 20 part√≠culas por clique (pode ajustar esse n√∫mero)
        smokeParticles.push({
          x: e.clientX,
          // posi√ß√£o X inicial: posi√ß√£o do clique (coordenada do mouse)
          y: e.clientY,
          // posi√ß√£o Y inicial: posi√ß√£o do clique
          radius: Math.random() * 4 + 3,
          // raio/tamanho inicial: valor aleat√≥rio entre 3 e 7
          alpha: Math.random() * 0.5 + 0.5,
          // transpar√™ncia inicial: aleat√≥rio entre 0.5 e 1.0
          dx: (Math.random() * 2 - 1),
          // velocidade horizontal: aleat√≥ria entre -1 e +1 (dispers√£o lateral)
          dy: Math.random() * 1 + 0.5
          // velocidade vertical: aleat√≥ria entre 0.5 e 1.5 (movimenta pra baixo/para cima conforme coordenadas)
        });
      }
    });

    // Atualiza e desenha as part√≠culas
    function animate() {
      // Fun√ß√£o chamada em loop (requestAnimationFrame) para animar as part√≠culas

      ctx.fillStyle = "rgba(0, 0, 0, 0.2)"; // cria efeito de rastro
      // Preenche o canvas com um ret√¢ngulo sem apagar totalmente, gerando "rastro" (motion blur)
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Desenha o ret√¢ngulo cobrindo todo o canvas

      for (let i = 0; i < smokeParticles.length; i++) {
        // Percorre todas as part√≠culas existentes
        const p = smokeParticles[i];
        // 'p' √© a part√≠cula atual (encurtamento da refer√™ncia)

        p.x += p.dx;
        // Atualiza a posi√ß√£o X com a velocidade horizontal

        p.y += p.dy;
        // Atualiza a posi√ß√£o Y com a velocidade vertical

        p.alpha -= 0.01;
        // Diminui gradualmente a opacidade (fade out). Ajustar esse valor altera dura√ß√£o.

        p.radius += 0.05;
        // Aumenta levemente o raio com o tempo (part√≠culas "incham")

        if (p.alpha <= 0) {
          // Se a part√≠cula ficou totalmente transparente:
          smokeParticles.splice(i, 1);
          // Remove a part√≠cula do array para liberar mem√≥ria e evitar processamento desnecess√°rio
          i--;
          // Ajusta o √≠ndice porque removemos um elemento do array
          continue;
          // Pula para a pr√≥xima itera√ß√£o
        }

        // mistura de marrom, branco e preto (poeira)
        ctx.beginPath();
        // Inicia um novo caminho de desenho no canvas

        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        // Desenha um c√≠rculo na posi√ß√£o (p.x,p.y) com raio p.radius

        const r = 100 + Math.random() * 60;
        // Gera componente vermelho entre 100 e 160 (varia√ß√£o para deixar cor org√¢nica)

        const g = 80 + Math.random() * 40;
        // Gera componente verde entre 80 e 120

        const b = 50 + Math.random() * 30;
        // Gera componente azul entre 50 e 80

        ctx.fillStyle = `rgba(${r},${g},${b},${p.alpha})`;
        // Define a cor de preenchimento usando r,g,b e alpha (transpar√™ncia da part√≠cula)

        ctx.fill();
        // Preenche o c√≠rculo desenhado (a part√≠cula aparece na tela)
      }

      requestAnimationFrame(animate);
      // Pede ao navegador para chamar 'animate' no pr√≥ximo frame (loop cont√≠nuo)
    }

    animate();
    // Inicia a anima√ß√£o chamando a fun√ß√£o pela primeira vez

  </script>
  <!-- Fim do script -->
</body>
</html>
